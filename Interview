springboot
Struts
Mybatis
Hibernate   1
Jsp
算法
Rabbitmq
Redis
Git
Docker  2
设计模式
mysql／oracle
shiro
swagger
quartz   3




简历：
项目经验：
写3个
1。人力工时系统
项目描述：
所用技术点：前台模版thymeleaf，基于springboot，通过shiro控制权限，redis集中会话管理，整合一个完整的后台代码实现

我负责的：登录认证和动态的权限管理；
登录认证：在登录的 Contoller 方法接收前台传入的用户名和密码封装成 UsernamePasswordToken 对象，然后交给 SecurityUtils.getSubject() 的主体，调用 login 登陆方法，调用登录方法后，shiro 会委托 SecurityManager 进行身份认证，最终的认证逻辑实现写在我们自定义的 Realm 中；为了实现登录认证和授权的方法，我们需要自定义 Realm 继承 AuthorizingRealm，然后重写 doGetAuthenticationInfo 方法实现身份认证和 doGetAuthorizationInfo 方法实现授权。
doGetAuthenticationInfo：认证方法，根据前台传入的用户名和其他条件从数据库中找出账号对应的信息，并与前台传入的密码进行比对（shiro 将数据库中取出的密码跟 token 进行匹配）判断是否登录成功。这边还可以做其他的操作，比如账号的冻结判断等；
doGetAuthorizationInfo：授权方法，shiro 并不是在认证之后就马上对用户授权，而是在认证通过之后，接下来要访问的资源或者目标方法需要权限的时候才会调用 doGetAuthorizationInfo() 方法进行授权

2.dsc框架搭建 日志功能

功能描述：我负责的是整个的日志记录功能，因为这是一个分布式项目，为了解决传统日志运维日志分散，查询速度慢等痛点，方便维护，我们使用elk将日志进行集中管理；我的日志收集分为两部分：项目运行中的日志和访问日志，用户访问日志是通过网关收集，在网关的过滤器中收集到用户的详细信息，包括IP，访问的方法，携带的参数等，将用户信息封装成json，通过rabbitmq将消息传送出去，系统日志同样也是配置好具体格式发送到rabbitmq中，我们的elk是直接用的docker，
然后修改一下docker中logstash的配置文件，将input改成我们的rabbitmq 然后根据不同的队列分成不同的日志索引输出到elasticsearch中。最后打开kibana就可以自定义搜索查看日志

3.文件处理中心  client文件上传接口／报表功能
接收处理端：用排程定时接收数据源，将数据源压缩 ，上传到sftp ，给rabbitmq发消息
上传端：接收rabbitmq的消息，获取部门名字和文件名，到数据库查出部门的相关信息，到sftp上下载文件，然后登录server端，成功后，携带session封装在cooiker中再次调用server端的上传文件的接口。server端是别的部门用python写的服务端；
在上传服务端的过程中提供如果因为网络原因发送文件失败，将 重试三次，如果再失败，将会提供页面手动下载；为了预防server端api地址或者登录的账户密码发生改变，提供页面给运维人员进行增删改查



2.给一些部门提供计算后的数据：
一些部门每天需要前天工栈测试的重测率，某一个工栈在重测时出现的概率等数据。在后台计算出来的数据存放在redis中，因为每天大概有几十万条数据，如果每次计算都访问数据库的话，将会消耗性能，所有我们把结果都存入了redis 。我们提供页面供用户选择哪一天的测试报告，以table的形式呈现在页面，也可以以excel的形式导出；前端还提供jschart报表来显示每天或者每个月的通过率进行更直观的展示





























基础知识：
1.什么是对象
  万物皆对象
2.重载和重写的区别?
  重写：子类继承父类时，需要重写父类的方法
  重载：方法名相同，参数的类型，个数，顺序不同，返回值不作为重载的判断条件
3.面向对象的特征
  继承，多态，封装
4.线程安全和线程不安全的map
5.为什么用继承？
 答：为了实现代码的复用
…




1.jsp有哪些内置对象，作用是什么？
	request： 负责得到客户端的请求；
	response：负责向客户端发出相应；
	session：负责保存同一客户端一次会话过程中的一些信息；
	out：负责管理对客户端的输出；
	application：表示整个应用环境的信息；
	config：表示servletconfig
	exception：表示页面发生异常
	pagecontext：表示这个jsp页面上下文
	page：表示当前jsp页面本身


2.jsp有哪些动作，作用分别是什么？
	include：当页面被请求的时候引入一个文件
	forward：将请求转到另一个页面
	usebean：获得javabean的一个实例
	setproperty：设置javabean属性
	getproperty：获得javabean的属性；
	plugin：根据浏览器类型为java插件生成object或者embed两种标记

3.jsp常用指令有哪些？

    page：定义页面的一些属性，常用属性：contentType = "text/html;charset=utf-8"  pageEncoding = "utf-8"  session = "true"
		    功能：设定整个JSP网页的静态属性。
			语法：<%@ page 标签元素=“值”%>,比如 <%@ page language=“java”%>
		 	标签元素：language、import、contentType、session、errorPage、isErrorPage等等。
    include

		    功能：include指令用来向当前页面插入一个静态文件的内容。这个文件可以是JSP、HTML、文本或是Java程序。
		    语法：<%@ include file=“filename” %> 比如 <%@ include file=“111.txt” %>
		    标签元素：file
   
    taglib
		    功能：使用标签库定义新的自定义标签，在JSP页面中启用定制行为。
		    当页面引用了用户自定义标签时，taglib指令用于引用自定义标签库，并指定标签的前缀。
		    语法：<%@ taglib uri="URIToTagLibrary" prefix="tagPrefix" %>
		    如<%@ taglib uri="http://www.jspcentral.com/tags" prefix="JAXP" %>
		    标签元素：uri、Prefixpage指令元素的属性

4.页面间常用对象传递的方法？
	request,session,application,cookie;


5.jsp和servlet有哪些相同点和不同点，他们之间的联系是什么？
	答：jsp是servlet的扩展，本质上是servlet的简易方式，更强调应用的外表表达，jsp编译后是“类servlet
			最大的不同点在于：servlet的应用逻辑是在java文件中，并且完全从表示层中的html里分离开来。而jsp的
			情况是java和html可以组合成一个扩展名为 .jsp的文件。jsp更偏重于视图，servlet偏重于业务逻辑；

6.详细描述mvc  

	答：基于java的应用系统采用mvc设计模型
	model：模型，处理业务逻辑的模块。
	view：视图，负责页面显示，显示model的处理结果给用户
	controller：控制，负责每个请求的分发，把form数据传给model进行处理；
	

7.将iso-8859-1转换成utf-8编码方式；
	s = new String(str.getBytes("iso-8859-1"),"utf-8");

8.get和post的区别？
	a. get一般是获取数据，而post是用来向服务器传递数据；
	b. post比get携带的数据更多，get只能携带不超过2048个字符；
	c. get比post更加安全，因为get的参数都暴露在URL上；
	d. get限制form表单的数据集必须为ASCLL字符，而post支持整个ISO1 0646字符集；


9.jsp的四种范围？
 
 	a.page：代表一个页面相关的对象和属性；
 	b.request：跟一次请求相关；
 	c.session：跟用户相关；
 	d.application：跟应用程序相关；

10.几种会话跟踪技术？
	cookie,url重写,hidden表单隐藏域，session；

11.J2EE是什么？
	企业版本开发和部署服务器应用程序。


12.cookie和session的作用，区别，应用范围。
	cookie数据以文本文件格式保存在客户端，session储存在服务区端
	session存储在服务器上，会占用内存资源，当访问的用户过多，会加重服务器的负载；
	cookie 限制了只允许4kb数据量，而session是无限量的；

13.jstl是什么，优点？
	jstl是一个标准标签库。由四个定制标记库（core、format、xml、sql）和一对通用标记库验证器（ScriptFreeTLV和PermittedTaglibsTLV）组成





14.存储过程和函数的区别：
	存储过程是用户定义的一系列sql语句的集合，设计特定表或者其他对象的任务，用户可以调用存储过程
	而函数通常是数据库已经定义的方法，它接受参数并返回某种类型的值并且不涉及特定用户表；


框架 
struts

1.什么是struts？
	struts是一个非常优秀的mvc框架，基于model2设计模型，由传统的struts1和webwork两个经典框架发展而来；

2.struts的核心功能？
	
	a.允许pojo对象作为action，支持更多视图技术，基于spring aop 思想的拦截器机制，更易扩展；更强大，更易用输入校验功能；


3.struts2工作流程
	（1） 客户端（Client）向Action发用一个请求（Request）
	（2） Container通过web.xml映射请求，并获得控制器（Controller）的名字
	（3） 容器（Container）调用控制器（StrutsPrepareAndExecuteFilter或FilterDispatcher）。在Struts2.1以前调用FilterDispatcher，Struts2.1以后调用StrutsPrepareAndExecuteFilter
	（4） 控制器（Controller）通过ActionMapper获得Action的信息
	（5） 控制器（Controller）调用ActionProxy.
	（6） ActionProxy读取struts.xml文件获取action和interceptor stack的信息。
	（7） ActionProxy把request请求传递给ActionInvocation
	（8） ActionInvocation依次调用action和interceptor
	（9） 根据action的配置信息，产生result
	（10） Result信息返回给ActionInvocation
	（11） 产生一个HttpServletResponse响应
	（12） 产生的响应行为发送给客服端。


4.优点
	（1）所有的struts 应用程序都是基于client／server http 交换协议；
	（2）提供了对mvc的一个清晰的实现，包含很多对所有请求进行处理的关键组件，如：拦截器，OGNL表达式语言，堆栈；


5.拦截器和过滤器的区别

	1、拦截器是基于java的反射机制的，而过滤器是基于函数回调 。
	2、过滤器依赖与servlet容器，而拦截器不依赖与servlet容器 。
	3、拦截器只能对action请求起作用，而过滤器则可以对几乎所有的请求 起作用 。
	4、拦截器可以访问action上下文、值栈里的对象，而过滤器不能 。
	5、在action的生命周期中，拦截器可以多次被调用，而过滤器只能在容器初始化时被调用一次

6.拦截器有哪些？
	conversionError:类型转换错误拦截器
	exception:异常拦截器
	fileUpload:文件上传拦截器
	i18n:国际化拦截器
	logger:日志拦截器
	params:解析请求参数拦截器
	validation:校验拦截器 


——————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————————


spring

IOC（控制反转）：为什么要将bean交给spring管理？
	答：一般是我们需要什么类，就直接去new，但是使用spring之后，我们将所需要的类交给spring容器管理，当
	我们需要的时候，直接从容器取出来记可以了。这样的话，生命周期就不需要我们管理了，不要频繁的new对象，
	这样就节省了jvm 的堆内存，spring的bean默认是单例的，将类的一些信息放在方法区，大大节省了堆内存

	而且起到了一个解耦的作用。a需要b，不用new b，需要的时候spring直接将b给你。举个例子：公司老板依赖的是实现了程序员的人，并不是你，所以他想换你就换你。这个也可以叫做DI（依赖注入，解决对象之间的依赖关系。）

	●谁控制谁，控制什么：传统Java SE程序设计，我们直接在对象内部通过new进行创建对象，是程序主动去创建依赖对象；而IoC是有专门一个容器来创建这些对象，即由Ioc容器来控制对 象的创建；谁控制谁？当然是IoC 容器控制了对象；控制什么？那就是主要控制了外部资源获取（不只是对象包括比如文件等）。

	●为何是反转，哪些方面反转了：有反转就有正转，传统应用程序是由我们自己在对象中主动控制去直接获取依赖对象，也就是正转；而反转则是由容器来帮忙创建及注入依赖对象；为何是反转？因为由容器帮我们查找及注入依赖对象，对象只是被动的接受依赖对象，所以是反转；哪些方面反转了？依赖对象的获取被反转了。

1.什么是DI(依赖注入)，什么是控制反转，依赖注入的几种方式？
	a.构造器注入；
	b.setter方法注入；
	c.接口注入；

2.有几种配置bean的方式
	a.基于xml的配置；
	b.基于注解的配置
	c.基于java的配置

3.springbean的生命周期

	（1）实例化一个bean
	（2）按照spring上下文对实例化的bean进行配置，也就是ioc注入；
	（3）如果这个bean已经实现了beanNameAware接口，会调用它实现的setBeanName(String)方法，传递的参数就是
		spring配置文件中bean的ID值；
	（4）如果这个bean已经实现了BeanFactoryAware接口，会调用它的实现的setBeanFactory(BeanFactory)传递的是
		spring工厂本身；
	（5）如果这个bean已经实现了ApplicationContextAware接口，会调用setApplicationContnext(ApplicationContext)
		方法，传入spring上下文；
	（6）如果这个bean关联了BeanPostProcessor接口，将会调用postProcessBeforeInitialization(Object obj,String s)
		方法；
	（7）如果bean在spring配置文件中配置了init-method属性会自动调用其配置的初始化方法。
	（8）如果这个Bean关联了BeanPostProcessor接口，将会调用postProcessAfterInitialization(Object obj, String s)方法
	（9）当bean不再需要时，会经过清理阶段，如果bean实现了disposableBean 这个接口，会调用那个其实现的destroy()方法；
	（10）最后，如果这个bean的spring配置了destroy-method属性，会自动调用其配置的销毁方法。
4.spring有哪些作用域，联系是什么
	（1）singleton(单例)：无论有多少个引用，始终指向同一个对象；作用域是默认作用域  singleton
	（2）prototype ：容器将会创建一个新的bean实例，每个实例都有自己的属性和状态；
	（3）request：在一次http请求中，容器会返回该bean的同一实例，而对不同的session请求则会创建新的实例 ，该bean实例仅在当前session内有效。
	（4）session：
	（5）global session

5.springbean是线程安全的吗？
	实际上，大部分的 Spring bean 并没有可变的状态 ( 比如 Service 类和 DAO 类 ) ，所以在某种程度上说 Spring 的单例 bean 是线程安全的 。 如果你的 bean 有多种状态的话（比如 View Model 对象），就需要自行保证线程安全 。﻿﻿


6.spring框架中用到了哪些设计模式？
	工厂模式 —BeanFactory 用来创建对象的实例
	代理模式 — 在 AOP 和 remoting 中被用的比较多 。﻿﻿
	单例模式 — 在 spring 配置文件中定义的 bean 默认为单例模式 。﻿﻿

7.springmvc有哪些优点？
	
	(1)spring属于低侵入式设计，代码的污染极低；
	(2)spring的DI机制将对象之间的依赖关系交由框架处理，减低组件的耦合性；
	(3)Spring提供了AOP技术，支持将一些通用任务，如安全、事务、日志、权限等进行集中式管理，从而提供更好的复用。
	(4)spring对于主流的应用框架提供了集成支持。
	(5)可以任意使用各种视图技术 , 而不仅仅局限于 JSP﻿
	(6)它是基于组件技术的,全部的应用对象 , 无论控制器和视图 , 还是业务对象之类的都是 java 组件 
	(7)提供的其他基础结构紧密集成 .﻿

8.spring框架的事务管理有哪些优点？
	它为不同的事务 API 如 JTA ， JDBC ， Hibernate ， JPA 和 JDO ，提供一个不变的编程模式 。﻿
	它为编程式事务管理提供了一套简单的 API 而不是一些复杂的事务 API。﻿
	它支持声明式事务管理 。﻿
	它和 Spring 各种数据访问抽象层很好的集成 。


9.AOP 的应用场景、原理 、AOP 好处？

	AOP–Aspect Oriented Programming 面向切面编程；用来封装横切关注点，具体可以在下面的场景中使用:﻿﻿
	原理： AOP 是面向切面编程，是通过动态代理的方式为程序添加统一功能，集中解决一些公共问题 。
		Authentication 权限﻿
		Caching 缓存﻿
		Context passing 内容传递﻿
		Error handling 错误处理﻿
		Lazy loading 懒加载﻿
		Debugging 调试﻿
		logging, tracing, profiling and monitoring 记录跟踪优化校准﻿
		Performance optimization 　性能优化﻿
		Persistence 持久化﻿
		Resource pooling 　资源池﻿
		Synchronization 　同步﻿
		Transactions 事务﻿
	优点： ﻿
		* 各个步骤之间的良好隔离性耦合性大大降低 。 ﻿
		* 源代码无关性，再扩展功能的同时不对源码进行修改操作

10.spring 中常见的创建对象的注解有哪些？
		@Component﻿，@Controller﻿，@Service﻿，@Repository﻿


11.Spring 管理事务的方式有几种？﻿

	1、编程式事务，在代码中硬编码。(不推荐使用)﻿﻿

	2、声明式事务，在配置文件中配置（推荐使用）﻿﻿

	声明式事务又分为两种：﻿﻿

	a、基于XML的声明式事务﻿﻿

	b、基于注解的声明式事
务﻿﻿


12. spring 中的核心类有那些，各有什么作用？﻿

	BeanFactory：产生一个新的实例，可以实现单例模式。﻿﻿

	BeanWrapper：提供统一的 get 及 set 方法。﻿﻿

	ApplicationContext：提供框架的实现，包括 BeanFactory 的所有功能。﻿﻿




13. spring 中有哪些代理方式？实现原理是什么？这些方式的优缺点是什么？﻿

	1、若目标对象实现了若干接口， spring 使用 JDK 的 java.lang.reflect.Proxy 类代理 。﻿﻿
		优点：因为有接口，所以使系统更加松耦合﻿﻿
		缺点：为每一个目标类创建接口﻿

	2、若目标对象没有实现任何接口， spring 则使用 CGLIB 库生成目标对象的子类 。﻿﻿
	优点：因为代理类与目标类是继承关系，所以不需要有接口的存在 。﻿﻿
	缺点：因为没有使用接口，所以系统的耦合性没有使用 JDK 的动态代理好 。﻿﻿



14.说说 IoC 容器的初始化过程？﻿

	Resource 定位：我们一般使用外部资源来描述 Bean 对象，所以 IOC 容器第一步就是需要定位 Resource 外部资源 。Resource 的定位其实就是 BeanDefinition 的资源定位，它是由 ResourceLoader 通过统一的 Resource 接口来完成的，这个 Resource 对各种形式的 BeanDefinition 的使用都提供了统一接口 。﻿

	载入：第二个过程就是 BeanDefinition 的载入 ,BeanDefinitionReader 读取 , 解析 Resource 定位的资源，也就是将用户定义好的 Bean 表示成 IOC 容器的内部数据结构也就是 BeanDefinition, 在 IOC 容器内部维护着一个 BeanDefinition Map 的数据结构，通过这样的数据结构， IOC 容器能够对 Bean 进行更好的管理 。 在配置文件中每一个都对应着一个 BeanDefinition 对象 。﻿

	注册：第三个过程则是注册，即向 IOC 容器注册这些 BeanDefinition ，这个过程是通过 BeanDefinitionRegistery 接口来实现的 。﻿


15. 说说 BeanFactory 和 ApplicationContext 的区别？ 什么是延迟实例化，它的优缺点是什么？﻿

   两者装载 bean 的区别 ﻿
	* BeanFactory ：在启动时不会去实例化 Bean ，只有从容器中获取 Bean 时才会去实例化。 ﻿
	* ApplicationContext ：在启动的时候就把所有的 Bean 全部实例化了 (好处是在配置中的任何错误就会立刻被发现，否则可能要花几个小时甚至几天，缺点是开销比较的大)。 它还可以为 Bean 配置 lazy-init=true 来让 Bean 延迟实例化。﻿﻿

spring初始化的时候只会实例化单例与非延迟加载（lazy-init="true"）的对象。其他的对象是在调用getBean的时候进行实例化。

16. 说说 AOP 的实现原理？动态代理的方式有哪些？﻿

	Spring AOP 使用的是动态代理，所谓的动态代理就是说 AOP 框架不会去修改字节码，而是在内存中临时为方法生成一个 AOP 对象，这个 AOP 对象包含了目标对象的全部方法，并且在特定的切点做了增强处理，并回调原对象的方法 。﻿﻿
	Spring AOP 中的动态代理主要有两种方式，

	 JDK 动态代理和 CGLIB 动态代理 。 ﻿

	* JDK 动态代理通过反射来接收被代理的类，并且要求被代理的类必须实现一个接口 。JDK 动态代理的核心是 InvocationHandler 接口和 Proxy类 。 ﻿

	* 如果目标类没有实现接口，那么 Spring AOP 会选择使用 CGLIB 来动态代理目标类 。CGLIB （ Code Generation Library ），是一个代码生成的类库，可以在运行时动态的生成某个类的子类，注意， CGLIB 是通过继承的方式做的动态代理，因此如果某个类被标记为 final ，那么它是无法使用 CGLIB 做动态代理的 


17.spring的优点
mybtis

1、#{}和${}的区别是什么？
	#{}是预编译处理，${}是字符串替换。
	Mybatis在处理#{}时，会将sql中的#{}替换为?号，调用PreparedStatement的set方法来赋值；
	Mybatis在处理${}时，就是把${}替换成变量的值。
	使用#{}可以有效的防止SQL注入，提高系统安全性。
2、当实体类中的属性名和表中的字段名不一样 ，怎么办 ？
第1种： 通过在查询的sql语句中定义字段名的别名，让字段名的别名和实体类的属性名一致
第2种： 通过<resultMap>来映射字段名和实体类属性名的一一对应的关系


3、通常一个Xml映射文件，都会写一个Dao接口与之对应，请问，这个Dao接口的工作原理是什么？Dao接口里的方法，参数不同时，方法能重载吗？


	Dao接口，就是人们常说的Mapper接口，接口的全限名，就是映射文件中的namespace的值，接口的方法名，就是映射文件中MappedStatement的id值，接口方法内的参数，就是传递给sql的参数。Mapper接口是没有实现类的，当调用接口方法时，接口全限名+方法名拼接字符串作为key值，可唯一定位一个MappedStatement，举例：com.mybatis3.mappers.StudentDao.findStudentById，可以唯一找到namespace为com.mybatis3.mappers.StudentDao下面id = findStudentById的MappedStatement。在Mybatis中，每一个<select>、<insert>、<update>、<delete>标签，都会被解析为一个MappedStatement对象。

	Dao接口里的方法，是不能重载的，因为是全限名+方法名的保存和寻找策略。

	Dao接口的工作原理是JDK动态代理，Mybatis运行时会使用JDK动态代理为Dao接口生成代理proxy对象，代理对象proxy会拦截接口方法，转而执行MappedStatement所代表的sql，然后将sql执行结果返回。


4、mybatis提供了哪几种标签？
Mybatis提供了9种动态sql标签：trim|where|set|foreach|if|choose|when|otherwise|bind。
其执行原理为，使用OGNL从sql参数对象中计算表达式的值，根据表达式的值动态拼接sql，以此来完成动态sql的功能。




3、介绍一下Hibernate的二级缓存
按照以下思路来回答：(1)首先说清楚什么是缓存，(2)再说有了hibernate的Session就是一级缓存，即有了一级缓存，为什么还要有二级缓存，(3)最后再说如何配置Hibernate的二级缓存。
(1)缓存就是把以前从数据库中查询出来和使用过的对象保存在内存中(一个数据结构中)，这个数据结构通常是或类似Hashmap，当以后要使用某个对象时，先查询缓存中是否有这个对象，如果有则使用缓存中的对象，如果没有则去查询数据库，并将查询出来的对象保存在缓存中，以便下次使用。
(2)Hibernate的Session就是一种缓存，我们通常将之称为Hibernate的一级缓存，当想使用session从数据库中查询出一个对象时，Session也是先从自己内部查看是否存在这个对象，存在则直接返回，不存在才去访问数据库，并将查询的结果保存在自己内部。由于Session代表一次会话过程，一个Session与一个数据库连接相关连，所以Session最好不要长时间保持打开，通常仅用于一个事务当中，在事务结束时就应关闭。并且Session是线程不安全的，被多个线程共享时容易出现问题。通常只有那种全局意义上的缓存才是真正的缓存应用，才有较大的缓存价值，因此，Hibernate的Session这一级缓存的缓存作用并不明显，应用价值不大。Hibernate的二级缓存就是要为Hibernate配置一种全局缓存，让多个线程和多个事务都可以共享这个缓存。我们希望的是一个人使用过，其他人也可以使用，session没有这种效果。
(3)二级缓存是独立于Hibernate的软件部件，属于第三方的产品，多个厂商和组织都提供有缓存产品，例如，EHCache和OSCache等等。在Hibernate中使用二级缓存，首先就要在hibernate.cfg.xml配置文件中配置使用哪个厂家的缓存产品，接着需要配置该缓存产品自己的配置文件，最后要配置Hibernate中的哪些实体对象要纳入到二级缓存的管理中。明白了二级缓存原理和有了这个思路后，很容易配置起Hibernate的二级缓存。扩展知识：一个SessionFactory可以关联一个二级缓存，也即一个二级缓存只能负责缓存一个数据库中的数据，当使用Hibernate 的二级缓存后，注意不要有其他的应用或SessionFactory来更改当前数据库中的数据，这样缓存的数据就会与数据库中的实际数据不一致。



4.mybatis和hibernate的区别？
相同点：都是基于对象关系模型，ORM。
mybatis是半自动化的，sql写在xml里，便于管理， 解除sql与程序代码的耦合，同时可以防止SQL注入。hibernate是全自动的，sql很多都是自动生成的，无法直接维护sql,写sql的灵活度上hibernate不及mybatis。

Hibernate的优点：
1、hibernate是全自动，hibernate完全可以通过对象关系模型实现对数据库的操作，拥有完整的JavaBean对象与数据库的映射结构来自动生成sql。
2、功能强大，数据库无关性好，O/R映射能力强，需要写的代码很少，开发速度很快。
3、有更好的二级缓存机制，可以使用第三方缓存。
4、数据库移植性良好。
5、hibernate拥有完整的日志系统，hibernate日志系统非常健全，涉及广泛，包括sql记录、关系异常、优化警告、缓存提示、脏数据警告等
Hibernate的缺点：
1、学习门槛高，精通门槛更高，程序员如何设计O/R映射，在性能和对象模型之间如何取得平衡，以及怎样用好Hibernate方面需要的经验和能力都很强才行
2、hibernate的sql很多都是自动生成的，无法直接维护sql；虽然有hql查询，但功能还是不及sql强大，见到报表等变态需求时，hql查询要虚，也就是说hql查询是有局限的；hibernate虽然也支持原生sql查询，但开发模式上却与orm不同，需要转换思维，因此使用上有些不方便。总之写sql的灵活度上hibernate不及mybatis。


Mybatis的优点：
1、易于上手和掌握，提供了数据库查询的自动对象绑定功能，而且延续了很好的SQL使用经验，对于没有那么高的对象模型要求的项目来说，相当完美。
2、sql写在xml里，便于统一管理和优化，解除sql与程序代码的耦合。
3、提供映射标签，支持对象与数据库的orm字段关系映射
4、 提供对象关系映射标签，支持对象关系组建维护
5、提供xml标签，支持编写动态sql。
6、速度相对于Hibernate的速度较快
Mybatis的缺点：
1、关联表多时，字段多的时候，sql工作量很大。
2、sql依赖于数据库，导致数据库移植性差。
3、由于xml里标签id必须唯一，导致DAO中方法不支持方法重载。
4、对象关系映射标签和字段映射标签仅仅是对映射关系的描述，具体实现仍然依赖于sql。
5、DAO层过于简单，对象组装的工作量较大。
6、不支持级联更新、级联删除。
7、Mybatis的日志除了基本记录功能外，其它功能薄弱很多。
8、编写动态sql时,不方便调试，尤其逻辑复杂时。
9、提供的写动态sql的xml标签功能简单，编写动态sql仍然受限，且可读性低。









---------------shiro-----------------------------------------------

Shiro的优点
	简单的身份认证, 支持多种数据源
    对角色的简单的授权, 支持细粒度的授权(方法级)
    支持一级缓存，以提升应用程序的性能；
    内置的基于 POJO 企业会话管理, 适用于 Web 以及非 Web 的环境
    非常简单的加密 API
    不跟任何的框架或者容器捆绑, 可以独立运行
Shiro 架构 核心组件:
    Authenticator:管理登陆登出
    Autorizer:授权器赋予主体有那些权限
    session Manager：shiro自己实现session管理器
    session DAO：提供了session的增删改插
    Cache Manager：缓冲管理器
    Raelms：和数据库交互的桥梁
  
shiro认证过程
	创建SecurityManager -> 主体提交认证 -> SecurityManager认证 -> Authenticator认证 -> Realm验证

shiro 授权过程
	创建SecurityManager -> 主体授权 -> securityManager授权 -> Authorizer授权 ->Realm获取权限数据

继承AuthorizingRealm 重写doGetAuthorizationInfo()和doGetAuthenticationInfo()





算法：
-----冒泡：
//		for(int i = 0;i<arr.length-1;i++){
//			for(int j = i+1;j<arr.length;j++){
//				if(arr[i]>arr[j]){
//					int temp = arr[i];
//					arr[i] = arr[j];
//					arr[j] = temp;
//				}
//			}
//		}
		
		for(int i = 0;i<arr.length-1;i++) {
			for(int j=0;j<arr.length-1-i;j++) {
				if(arr[j] >arr[j+1]) {
					int temp = arr[j];
					arr[j] = arr[j+1];
					arr[j+1] = temp;
				}
			}
		}

-----快排：
public static void fast(int[] arr,int left,int right) {
	    int l = left;
	    int r = right;
	    int base = arr[left];
	     
	    while(l<r) {
	    	while(l<r && arr[r]  >= base) {
	    		r--;
	    	}if(l<r) {
	    		int temp = arr[r];
	    		arr[r] = arr[l];
	    		arr[l] = temp;
	    		l++;
	    	}
	    	
	    	while(l<r && arr[l]  <= base) {
	    		l++;
	    	}if(l<r) {
	    		int temp = arr[r];
	    		arr[r] = arr[l];
	    		arr[l] = temp;
	    		r--;
	    	}
	    	
	    }
	   
	    if(l>left) {
	    	fast(arr,left,l-1);
	    }if(r<right) {
	    	fast(arr,l+1,right);
	    }

	}



	
-----二分查找：
public static int erfen(int [] arr,int left,int right,int num) {
		
	if(num < arr[left]  || num > arr[right]  || left > right) {
		return -1;
	}	

		int mids = left+right /2;
		int mid = arr[mids];
		System.out.println("mids:"+mids+"  mid:  "+mid);
		if(num < mid) {
			return  erfen(arr, left,mids-1,num);
		}if(num > mid) {
			return erfen(arr,mids+1,right,num);
		}else {
			return mids;
		}
	}














多线程

1.进程和线程的区别？
 答：进程：每个进程都有独立的代码和数据空间，进程间切换会有较大的开销，一个进程包含1--n个线程，多进程是指操作系统能同时运行多个任务（程序）
    线程：同类线程共享代码和数据空间，每个线程有独立的运行栈和程序计数器，线程切换开销小；多线程是指在同一程序中有多个顺序流在执行。

2.线程和进程的阶段？
创建、就绪、运行、阻塞、终止
阻塞状态又分为：
	等待阻塞：运行的线程执行wait（）方法，jvm会把该线程放入等待池中
	同步阻塞：运行的线程在获取对象的同步锁时，若该同步锁被别的线程占用，则JVM会把该线程放入锁池中。
	其他阻塞：运行的线程执行sleep（）或join（） 方法，或者发出了I/O请求时，jvm会把该线程设置为阻塞状态，当sleep（）状态超时、
	join（）等待线程终止或者超时、或者I\O处理完毕时，线程重新就绪状态；
3.在java中要想实现多线程，有两种手段，一种是继续Thread类，另外一种是实现Runable接口。


4.调整线程优先级：java线程有优先级，优先级高的线程会获得较多的运行机会。
优先级的取值范围是1～10，Thread类有以下三个静态常量：
static int MAX_PRIORITY  线程可以具有的最高优先级，取值为10；
static int MIN_PRIORITY  线程可以具有的最高优先级，取值为1；
static int MORM_PRIORITY 线程可以具有的最高优先级，取值为5；

Thread类 setPriority()和getPriority()方法分别用来设置和获取线程的优先级。

sleep ：线程睡眠，使线程转到阻塞状态，millis参数可以设定睡眠时间，以毫秒为单位，当睡眠结束后，就转为就绪状态
wait：导致当前的线程等待，直到其它线程调用此对象的notify()方法或notifyAll()唤醒方法，等价于wait(0)一样。
yield：线程让步，暂停当前正在执行的线程对象，把执行机会让给相同或者更高优先级的线程。进入就绪状态。
join：等待其他线程终止，在当前线程中调用另一个线程的join方法，则当前线程转入阻塞状态，直到另一个进程运行结束，当前线程再由阻塞转为就绪状态。
notify()：线程唤醒：Object类中的notify()方法，唤醒在此对象监视器上等待的单个线程。如果所有线程都在此对象上等待，则会选择唤醒其中一个线程。选择是任意性的，并在对实现做出决定时发生。线程通过调用其中一个 wait 方法，在对象的监视器上等待。 直到当前的线程放弃此对象上的锁定，才能继续执行被唤醒的线程。被唤醒的线程将以常规方式与在该对象上主动同步的其他所有线程进行竞争；例如，唤醒的线程在作为锁定此对象的下一个线程方面没有可靠的特权或劣势。类似的方法还有一个notifyAll()，唤醒在此对象监视器上等待的所有线程








git
Git 有三种状态：已提交（committed）、已修改（modified）、已暂存（staged）；
Git 项目的三个工作区域的概念：Git 仓库、工作目录以及暂存区域




设计模式：
单例模式：确保某个类只有一个实例，
懒汉模式：（线程不安全）因为没有加锁synchronized. 

public class DanLiMoShi1 { 
	private static DanLiMoShi1 instance; 
	private DanLiMoShi1 (){} 
	public static DanLiMoShi1 getInstance() { 
		if (instance == null) { //如果有了实例了，就不需要要创建了 
		instance = new DanLiMoShi1(); 
	} 
		return instance; 
	} 
	public void SayLove(){ 
		System.out.println("Love You Baby!"); 
	} 
}



懒汉模式（线程安全），但是效率低
synchronized
class Lanhan{
private static Lanhan  lanhan;
	private  Lanhan() {}
	public static synchronized  Lanhan  getInstance() {
		if(lanhan == null) {
			System.out.println("ss");
			lanhan = new Lanhan();
		}
		
		return lanhan;
	}
}

饿汉模式：  线程安全，没有加锁，但是类加载就初始化，浪费内存
public class EhanAnQuan {
	private  static  EhanAnQuan  ehan = new EhanAnQuan();
	
	private EhanAnQuan() {}
	public static EhanAnQuan  getInstances() {
		return ehan;
	}
	
}


BufferedInputStream 本身是不具备读文件的能力，所以需要借助FileInputStream，实际使用的就是装饰者模式进行包装






Rabbitmq

4种交换机类型
fanout  direct topic  heard  



6种队列模式
Hello : 一个生产者p 发送消息到队列 Q，一个消费者C接收；
Work Queue：工作队列模式，一个生产者，多个消费者，每个消费者获取到的消息唯一，多个消费者只有一个队列

Exchanges
Publish/Subscribe
Routing
Topics


Rpc Request/reply








——————————————
线程：
（1）实现runnable接口：    Test implements  Runnable    开始方式：new  Thread(new Test).start
（2）继承Thread  类       Test extends  Thread   开始方式：  new Test().start
且都要实现run方法，，获取当前线程的方法：Thread.currentThread()  .sleep(1*1000)睡1s   


———————————————————
网络协议：http  tcp／IP
OSI网络七层协议：应用层（HTTP、FTP、SMTP、POP3、TELNET）-》表示层 -》会话层 -》传输层（TCP/UDP） -》网络层（IP） -》数据链路层 -》物理层
Http协议：一个完整的http请求内容包括：一个请求行（包括请求方式，url 版本号），
        若干请求头（accept, host, user-agent,encoding,connection,cookie），实体内容；


Tcp协议：是面向连接的通信协议，三次握手 A——>B;B——A；A——B



create or replace trigger trigger name  before|after   update|delete|select|insert 
On
Table name
Begin
Sql
End





————————————————————————————————————————————————————————————————————————————————
Poi 报表组件
 (1).操作excel组件是 HSSF，操作word的是HWPF
 (2).首先，理解一下一个Excel的文件的组织形式，一个Excel文件对应于一个workbook(HSSFWorkbook)，一个workbook可以有多个sheet（HSSFSheet）组成，一个sheet是由多个row（HSSFRow）组成，一个row是由多个cell（HSSFCell）组成。
 (3) HSSF 只支持 2007前的excel，扩展名是xls， XSSF支持2007 以后的
mybatis面试：
hibernate面试：
docker
shiro
算法（快排，冒泡，插入）
数据库  
网络协议（http|https，tcp|udp）
redis
rabbitmq：为什么选择？
有消息确认机制，使用简单。
项目打包
jquery
#10.175.93.17:5000/dsc-insight-producer-0.0.1-httptest
